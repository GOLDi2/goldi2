{"version":3,"file":"event_queue.js","sourceRoot":"","sources":["event_queue.ts"],"names":[],"mappings":"AAAA;;GAEG;AAGH;IAOI;QALA,UAAK,GAAY,EAAE,CAAC,CAAC,KAAK;QAC1B,UAAK,GAAY,EAAE,CAAC,CAAC,KAAK;QAC1B,qEAAqE;QAC7D,cAAS,GAAG,IAAI,CAAC;QAIrB,IAAI,CAAC,YAAY,EAAE,CAAA;IACvB,CAAC;IAEM,SAAS,CAAC,KAAK;QAElB,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,CAC3B,CAAC;YACG,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACxB,CAAC;QACD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC/B,CAAC;IAAA,CAAC;IAEM,aAAa;QAEjB,IAAI,KAAK,GAAK,IAAI,CAAC,SAAS,CAAC;QAC7B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACtB,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EACvB,CAAC;YACG,IAAI,CAAC,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;YACtB,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAC7B,CAAC;IACL,CAAC;IAAA,CAAC;IAEM,OAAO;QAEX,MAAM,CAAC,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC;IAChC,CAAC;IAAA,CAAC;IAEM,YAAY;QAEhB,IAAI,KAAK,GAAQ,IAAI,CAAC,OAAO,EAAE,CAAC;QAChC,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,wDAAwD;QACxD,yFAAyF;QACzF,OAAO,IAAI,CAAC,SAAS,IAAI,IAAI,IAAI,UAAU,GAAG,GAAG,EACjD,CAAC;YACG,IAAI,CAAC,aAAa,EAAE,CAAC;YACrB,UAAU,IAAI,CAAC,CAAC;QACpB,CAAC;QACD,MAAM,CAAC,UAAU,CAAC,MAAK,IAAI,CAAC,YAAY,EAAE,EACxB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAChG,CAAC;IAAA,CAAC;CAEL","sourcesContent":["/**\n * Created by mseeber on 5/11/17.\n */\n\n\nclass EventQueue\n{\n    delay          = 50; // ms\n    limit          = 40; // ms\n    //TODO rewrite it so this is never null, maybe use \"double buffering\"\n    private nextQueue = null;\n    \n    constructor()\n    {\n        this.timerHandler()\n    }\n    \n    public postEvent(event)\n    {\n        if (this.nextQueue == null)\n        {\n            this.nextQueue = [];\n        }\n        this.nextQueue.push(event);\n    };\n    \n    private dispatchEvent()\n    {\n        let queue   = this.nextQueue;\n        this.nextQueue = null;\n        while (queue.length > 0)\n        {\n            let e = queue.shift();\n            e.target.trigger(e.type);\n        }\n    };\n    \n    private getTime()\n    {\n        return new Date().getTime();\n    };\n    \n    private timerHandler()\n    {\n        let start      = this.getTime();\n        let iterations = 0;\n        //modified for better debugging: made timing-independant\n        //replaced with a static iterations limit to prevent freezing caused by instable circuits\n        while (this.nextQueue != null && iterations < 100)\n        { //original code:  && getTime() - start < limit\n            this.dispatchEvent();\n            iterations += 1;\n        }\n        window.setTimeout(() =>this.timerHandler(),\n                          Math.max(this.delay - this.limit, this.delay - (this.getTime() - start)));\n    };\n    \n}\n\n"]}