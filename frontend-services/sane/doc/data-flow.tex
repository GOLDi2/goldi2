\documentclass{scrartcl}

\usepackage{polyglossia}
\setmainlanguage{german}
\usepackage{fontspec}

\setmainfont{TeX Gyre Pagella}
\setmonofont{Source Code Pro}
\setsansfont{Source Sans Pro}

\usepackage{framed}
\usepackage[german]{hyperref}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usepackage{amsmath,bm,times}
\newcommand{\mx}[1]{\mathbf{\bm{#1}}} % Matrix command
\newcommand{\vc}[1]{\mathbf{\bm{#1}}} % Vector command

\hypersetup{unicode=true}

\title{SANE – Schaltsysteme-Arbeitsblätter im Netz}
\author{David Sukiennik}
\date{\today}

\begin{document}
\maketitle
\pagestyle{empty}

%% We need layers to draw the block diagram
%\pgfdeclarelayer{background}
%\pgfdeclarelayer{foreground}
%\pgfsetlayers{background,main,foreground}
%
%% Define a few styles and constants
%\tikzstyle{sensor}=[draw, fill=blue!20, text width=5em, text centered, minimum height=2.5em]
%\tikzstyle{ann} = [above, text width=5em]
%\tikzstyle{naveqs} = [sensor, text width=6em, fill=red!20, minimum height=12em, rounded corners]
%\tikzstyle{element} = [draw, fill=blue!20, text width=5em, minimum height=2.5em]
%\def\blockdist{2.3}
%\def\edgedist{2.5}
%
%\begin{tikzpicture}
%	\node (index) [element] {index.html};
%
%	\node (naveq) [naveqs] {Navigation equations};
%	% Note the use of \path instead of \node at ... below.
%	\path (naveq.140)+(-\blockdist,0) node (gyros) [sensor] {Gyros};
%	\path (naveq.-150)+(-\blockdist,0) node (accel) [sensor] {Accelero-meters};
%
%	% Unfortunately we cant use the convenient \path (fromnode) -- (tonode)
%	% syntax here. This is because TikZ draws the path from the node centers
%	% and clip the path at the node boundaries. We want horizontal lines, but
%	% the sensor and naveq blocks aren't aligned horizontally. Instead we use
%	% the line intersection syntax |- to calculate the correct coordinate
%	\path [draw, ->] (gyros) -- node [above] {$\vc{\omega}_{ib}^b$}
%	(naveq.west |- gyros) ;
%	% We could simply have written (gyros) .. (naveq.140). However, it's
%	% best to avoid hard coding coordinates
%	\path [draw, ->] (accel) -- node [above] {$\vc{f}^b$}
%	(naveq.west |- accel);
%	\node (IMU) [below of=accel] {IMU};
%	\path (naveq.south west)+(-0.6,-0.4) node (INS) {INS};
%	\draw [->] (naveq.50) -- node [ann] {Velocity } + (\edgedist,0)
%	node[right] {$\vc{v}^l$};
%	\draw [->] (naveq.20) -- node [ann] {Attitude} + (\edgedist,0)
%	node[right] {$\mx{R}_l^b$};
%	\draw [->] (naveq.-25) -- node [ann] {Horisontal position} + (\edgedist,0)
%	node [right] {$\mx{R}_e^l$};
%	\draw [->] (naveq.-50) -- node [ann] {Depth} + (\edgedist,0)
%	node[right] {$z$};
%
%	% Now it's time to draw the colored IMU and INS rectangles.
%	% To draw them behind the blocks we use pgf layers. This way we
%	% can use the above block coordinates to place the backgrounds
%	\begin{pgfonlayer}{background}
%		% Compute a few helper coordinates
%		\path (gyros.west |- naveq.north)+(-0.5,0.3) node (a) {};
%		\path (INS.south -| naveq.east)+(+0.3,-0.2) node (b) {};
%		\path[fill=yellow!20,rounded corners, draw=black!50, dashed] (a) rectangle (b);
%		\path (gyros.north west)+(-0.2,0.2) node (a) {};
%		\path (IMU.south -| gyros.east)+(+0.2,-0.2) node (b) {};
%		\path[fill=blue!10,rounded corners, draw=black!50, dashed] (a) rectangle (b);
%	\end{pgfonlayer}
%\end{tikzpicture}

\section{Komposition}
\label{chap:composition}
Die Nutzung von WebComponents erlaubt die Komposition aus Teilelementen.
In der \texttt{index.html} befindet sich das Element \texttt{sane-app}, das die Navigation, die Daten, die einzelnen Darstellungen etc.\ enthält.
Diese sind im Shadow DOM enthalten und für den Nutzer der Anwendung nicht sofort sichtbar.

Siehe auch: Polymer, Application Shell Architecture, Polymer Case Studies (Shop, News app)

\begin{figure}
\begin{framed}
	\texttt{index.html}
	\definecolor{shadecolor}{RGB}{150, 200, 250}
	\begin{shaded*}
		\texttt{<sane-app>}
		\definecolor{shadecolor}{RGB}{180, 220, 250}
		\begin{shaded*}
			\textit{Navigation, Layout, Menü, \ldots}
		\end{shaded*}
		\begin{shaded*}
			\texttt{<app-route>}
		\end{shaded*}
		\begin{shaded*}
			\texttt{<sane-data>}
		\end{shaded*}
		\begin{shaded*}
			\texttt{<sane-truth-table>}
		\end{shaded*}
		\begin{shaded*}
			\texttt{<sane-karnaugh-map>}
		\end{shaded*}
		\begin{shaded*}
			\texttt{<sane-venn-diagram>}
		\end{shaded*}
		\begin{shaded*}
			\texttt{\ldots}
		\end{shaded*}
	\end{shaded*}
\end{framed}
\caption{Beispiel der Komposition}
\end{figure}

\section{Data Flow}
Das Datenfluss-Modell orientiert sich am Unidirectional Data Flow.
Bei Polymer wird dies mittels One-Way Data Binding realisiert.
Dabei fließen Daten von oben nach unten, also vom Host-Element zu Kinder-Elementen (vgl.~\autoref{chap:composition}).
Das erschwert, dass Kinder-Elemente fehlerhafte oder unsinnige Einträge (wegen böswilliger Manipulation oder eines Bugs) ins Data Storage schreiben.

Sollen sich Einträge ändern, können die Kinder-Elemente Events, die wegen des Event Bubblings an die Eltern-Elemente weitergetragen werden, erzeugen.
Diese müssen sich an Namens- und Inhaltskonventionen halten, damit sie von der \texttt{sane-app} korrekt verarbeitet werden.
Diese prüft die Inhalte auf Sinnhaftigkeit, Korrektheit etc.\ und ändert ggf.\ Einträge im Data Storage.
Durch das One-Way Binding werden die Änderungen wieder an alle Kinder-Elemente propagiert und die Darstellungen werden automatisch aktualisiert.

Unidirectional Data Flow erleichtert auch das Debugging, da nicht jedes Element Änderungen vornehmen darf, sondern diese zentralisiert und gefiltert werden, und man die Ursache der Änderung leichter verfolgen kann.

(One-Way Data Binding wird auch von React, Redux etc.\ genutzt.)

Siehe auch: Polymer Data Binding, one-way und two-way data binding, UniFlow for Polymer

\end{document}
