Expression = head:Term tail:(_ ('+') _ Term)* _
{
    return tail.reduce(function(result, element) {
        if (head === '') {
        	return {bool:text()==1};
        }
        if (element[1] === '+') {
            if(Object.keys(result)[0] === 'or'){
                result.or.push(element[3]);
                return result;
            }else{
                return {or:[result,element[3]]};
            }
        }
    }, head);
}
Term = head:Element tail:((_('°')_ / _('~')_ / _('>')_ / _('&')_ / _)  Element)*
{
    return tail.reduce(function(result, element) {
        if (element[0].includes('°')) {
            if (Object.keys(result)[0] === 'antival'){
                result.antival.push(element[1]);
                return result;
            }else{
                return {antival:[result,element[1]]};
            }
        } else if (element[0].includes('~')) {
            if (Object.keys(result)[0] === 'equiv'){
                result.equiv.push(element[1]);
                return result;
            }else{
                return {equiv:[result,element[1]]};
            }
        } else if (element[0].includes('>')) {
            if (Object.keys(result)[0] === 'imply'){
                result.imply.push(element[1]);
                return result;
            }else{
                return {imply:[result,element[1]]};
            }
        } else if (element[0].includes('&')) {
            if (Object.keys(result)[0] === 'and'){
                result.and.push(element[1]);
                return result;
            }else{
                return {and:[result,element[1]]};
            }
        } else if (!element[2]) {
            if (Object.keys(result)[0] === 'and'){
                result.and.push(element[1]);
                return result;
            }else{
                return {and:[result,element[1]]};
            }
        }
    }, head);
}
Element =  '/' el:Element {return {not:el}}
    / '(' _ expr:Expression _ ')' { return expr }
    / Var
    / Bool
Var = [Xx][0-9]+ {
	return {variable:text().replace(/x/ig, '')};
}
Bool = [0-1]+ { return {bool:text()==1}; }
_ = [ \t\n\r]*
