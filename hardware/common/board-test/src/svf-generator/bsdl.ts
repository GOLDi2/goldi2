import { binToHex } from '../utils/utilityFunctions'
import * as bsdlFpgaRaw from './bsdl/machxo2/bsdl-machxo2.json'
import * as bsdlMcRaw from './bsdl/atmega2560/bsdl-atmega2560.json'

// Generated by https://quicktype.io

export interface BsdlRaw {
    component_name: string
    generic_parameter: GenericParameter
    logical_port_description: LogicalPortDescription[]
    standard_use_statement: string
    component_conformance_statement: string
    device_package_pin_mappings: DevicePackagePinMapping[]
    scan_port_identification: ScanPortIdentification[]
    instruction_register_description: InstructionRegisterDescription
    optional_register_description:
        | OptionalRegisterDescription
        | OptionalRegisterDescription[]
    register_access_description: RegisterAccessDescription[]
    boundary_scan_register_description: BoundaryScanRegisterDescription
    bsdl_extensions: null
    compliance_enable_description: null
    design_warning: null
    grouped_port_identification: null
    intest_description: null
    power_port_association_description: null
    register_assembly_description: null
    register_association_description: null
    register_constraints_description: null
    register_fields_description: null
    register_mnemonics_description: null
    runbist_description: null
    system_clock_description: null
    use_statement: null
}

interface BoundaryScanRegisterDescription {
    fixed_boundary_stmts: FixedBoundaryStmts
    segment_boundary_stmts: null
}

interface FixedBoundaryStmts {
    boundary_length: string
    boundary_register: BoundaryRegister[]
}

interface BoundaryRegister {
    cell_number: string
    cell_info: CellInfo
}

interface CellInfo {
    cell_spec: CellSpec
    input_or_disable_spec: InputOrDisableSpec | null
}

interface CellSpec {
    cell_name: string
    port_id: string | string[]
    function: Function
    safe_bit: '0' | '1' | 'X'
}

enum Function {
    Bidir = 'BIDIR',
    Control = 'CONTROL',
    Internal = 'INTERNAL',
    ObserveOnly = 'OBSERVE_ONLY',
}

interface InputOrDisableSpec {
    control_cell: string
    disable_value: '0' | '1'
    disable_result: DisableResult
}

enum DisableResult {
    Z = 'Z',
}

interface DevicePackagePinMapping {
    pin_mapping_name: string
    pin_map: PinMap[]
}

interface PinMap {
    port_name: string
    pin_list: string[]
    parseinfo: Array<ParseinfoEnum | number | null>
}

enum ParseinfoEnum {
    Port = 'port',
}

interface GenericParameter {
    default_device_package_type: string
}

interface InstructionRegisterDescription {
    instruction_length: string
    instruction_opcodes: InstructionOpcode[]
    instruction_capture: string[]
    instruction_private: string | string[]
}

interface InstructionOpcode {
    instruction_name: string
    opcode_list: string[]
}

interface LogicalPortDescription {
    identifier_list: string[]
    pin_type: PinType
    port_dimension: PortDimensionClass | PortDimensionEnum | string
}

enum PinType {
    In = 'in',
    Inout = 'inout',
    Linkage = 'linkage',
    Out = 'out',
}

interface PortDimensionClass {
    bit_vector: string[]
}

enum PortDimensionEnum {
    Bit = 'bit',
}

interface OptionalRegisterDescription {
    idcode_register: string
    usercode_register?: string
}

interface RegisterAccessDescription {
    register: Register
    instruction_capture_list: InstructionCaptureList[]
}

interface InstructionCaptureList {
    instruction_name: string
    pattern: null
}

interface Register {
    reg_name: string
    reg_length?: string
}

interface ScanPortIdentification {
    tap_scan_in?: string
    tap_scan_mode?: string
    tap_scan_out?: string
    tap_scan_clock?: TapScanClock
}

interface TapScanClock {
    frequency: string
    halt_value: string
}

// begin of custom types

/**
 * Interface for a boundary cell.
 */
export type BoundaryCell = {
    /**
     * Number of the boundary cell.
     */
    cellNumber: number
    /**
     * Pin connected to the boundary cell.
     */
    pin: string
    /**
     * Function of the boundary cell (e.g. "BIDIR" or "CONTROL").
     */
    function: string
    /**
     * The value the boundary cell can be safely set to.
     */
    safeBit: '0' | '1' | 'X'
    /**
     * Control cell for this boundary cell.
     */
    controllCell?: string
    /**
     * Value to disable the controlled boundary cell.
     */
    disableValue?: '0' | '1'
    /**
     * Resulting value when disabling the controlled boundary cell.
     */
    disableResult?: '0' | '1' | 'Z'
    /**
     * Value to enable the controlled boundary cell.
     */
    enableValue?: '0' | '1'
}

/**
 * Interface for parsed bsdl data.
 */
export interface BsdlData {
    /**
     * Ports of the device.
     */
    ports: Array<string>
    /**
     * Length of the instructions.
     */
    instructionLength: number
    /**
     * ID code of the device.
     */
    idcode: string
    /**
     * Available instructions.
     */
    instructions: {
        /**
         * IDCODE instruction.
         */
        idcode: string
        /**
         * SAMPLE/PRELOAD instruction.
         */
        sample: string
        /**
         * EXTEST instruction
         */
        extest: string
    }
    /**
     * Number of boundary cells.
     */
    boundaryCellsLength: number
    /**
     * Boundary cells of the device.
     */
    boundaryCells: Array<BoundaryCell>
}

/**
 * This function parses raw bsdl data into the desired format.
 * @param bsdl The raw bsdl data to be parsed.
 * @returns The parsed bsdl data.
 */
export function parseBsdl(bsdl: BsdlRaw): BsdlData {
    // parse ports
    const ports = new Array<string>()
    for (const desc of bsdl.logical_port_description) {
        if (desc.port_dimension === 'bit') {
            ports.push(desc.identifier_list.join(''))
        } else if (Object.keys(desc.port_dimension)) {
            const bit_vector = (desc.port_dimension as any).bit_vector
            const low = parseInt(bit_vector[0])
            const high = parseInt(bit_vector[2])
            if (low > high)
                throw new Error('something went wrong while parsing ports from bsdl file')
            for (let i = low; i < high; i++) {
                ports.push(desc.identifier_list[0] + '(' + i + ')')
            }
        } else {
            throw new Error('something went wrong while parsing ports from bsdl file')
        }
    }

    // parse instruction length
    const instructionLength = parseInt(
        bsdl.instruction_register_description.instruction_length
    )

    // parse instructions
    const instructions = {
        idcode: binToHex(
            bsdl.instruction_register_description.instruction_opcodes.find(
                (elem) => elem.instruction_name == 'IDCODE'
            )!.opcode_list[0]
        ),
        sample: binToHex(
            bsdl.instruction_register_description.instruction_opcodes.find(
                (elem) => elem.instruction_name == 'SAMPLE'
            )!.opcode_list[0]
        ),
        extest: binToHex(
            bsdl.instruction_register_description.instruction_opcodes.find(
                (elem) => elem.instruction_name == 'EXTEST'
            )!.opcode_list[0]
        ),
    }

    // parse idcode
    const idcode = Array.isArray(bsdl.optional_register_description)
        ? binToHex((bsdl.optional_register_description as any)[0].idcode_register)
        : binToHex((bsdl.optional_register_description as any).idcode_register)

    // parse boundary cells length (= amount of boundary cells)
    const boundaryCellsLength = parseInt(
        bsdl.boundary_scan_register_description.fixed_boundary_stmts.boundary_length
    )

    // parse boundary cells
    const boundaryCells = new Array<BoundaryCell>()
    for (const desc of bsdl.boundary_scan_register_description.fixed_boundary_stmts
        .boundary_register) {
        boundaryCells.push({
            cellNumber: parseInt(desc.cell_number),
            pin: Array.isArray(desc.cell_info.cell_spec.port_id)
                ? (desc.cell_info.cell_spec.port_id as any).join('')
                : desc.cell_info.cell_spec.port_id,
            function: desc.cell_info.cell_spec.function,
            safeBit: desc.cell_info.cell_spec.safe_bit,
            controllCell: desc.cell_info.input_or_disable_spec?.control_cell,
            disableValue: desc.cell_info.input_or_disable_spec?.disable_value,
            disableResult: desc.cell_info.input_or_disable_spec?.disable_result,
            enableValue: desc.cell_info.input_or_disable_spec?.disable_value
                ? desc.cell_info.input_or_disable_spec.disable_value == '1'
                    ? '0'
                    : '1'
                : undefined,
        })
    }

    return {
        ports: ports,
        instructionLength: instructionLength,
        instructions: instructions,
        idcode: idcode,
        boundaryCellsLength: boundaryCellsLength,
        boundaryCells: boundaryCells,
    }
}

export const bsdlFpga = parseBsdl(bsdlFpgaRaw as BsdlRaw)
export const bsdlMc = parseBsdl(bsdlMcRaw as BsdlRaw)
